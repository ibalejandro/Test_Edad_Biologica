CCS PCM C Compiler, Version 4.059, 41152               07-Abr-10 11:36

               Filename: C:\Documents and Settings\edgiral\Escritorio\Ejercicios Guia PICC, archivo C y proteus\Ejemplo 16.5\ejemplo 16.5.lst

               ROM used: 758 words (9%)
                         Largest free fragment is 2048
               RAM used: 20 (5%) at main() level
                         30 (8%) worst case
               Stack:    4 locations

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   208
0003:  NOP
.................... //Ejemplo 16.5  LCD y teclado. 
....................  
.................... //Digitar una clave en el teclado telefónico, en el LCD mostrar si es correcta  
.................... //o incorrecta. En el momento de estar digitando la clave en el LCD se  
.................... //muestran asteriscos en vez de los números. 
....................  
.................... #INCLUDE <16f886.h> 
.................... //////// Standard Header file for the PIC16F886 device //////////////// 
.................... #device PIC16F886 
.................... #list 
....................  
.................... #USE     DELAY(CLOCK=4000000) 
*
0079:  MOVLW  2F
007A:  MOVWF  04
007B:  BCF    03.7
007C:  MOVF   00,W
007D:  BTFSC  03.2
007E:  GOTO   08D
007F:  MOVLW  01
0080:  MOVWF  78
0081:  CLRF   77
0082:  DECFSZ 77,F
0083:  GOTO   082
0084:  DECFSZ 78,F
0085:  GOTO   081
0086:  MOVLW  4A
0087:  MOVWF  77
0088:  DECFSZ 77,F
0089:  GOTO   088
008A:  GOTO   08B
008B:  DECFSZ 00,F
008C:  GOTO   07F
008D:  RETLW  00
.................... #FUSES   XT,NOPROTECT,NOWDT,NOBROWNOUT,NOPUT,NOLVP 
.................... #DEFINE  USE_PORTB_LCD TRUE 
.................... #DEFINE  USE_PORTB_KBD           // Se añade esta instrucción porque por defecto  
....................                                  // el teclado se conecta al puerto D en este  
....................                                  // caso se esta usando el  puerto B.*/ 
.................... #INCLUDE<KBD.C>                  // Incluir en el encabezado el driver para  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             KBDD.C                                //// 
.................... ////                  Generic keypad scan driver                       //// 
.................... ////                                                                   //// 
.................... ////  kbd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  c = kbd_getc(c)  Will return a key value if pressed or /0 if not //// 
.................... ////                   This function should be called frequently so as //// 
.................... ////                   not to miss a key press.                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... ////////////////// The following defines the keypad layout on port D 
....................  
.................... // Un-comment the following define to use port B 
.................... // #define use_portb_kbd TRUE 
....................  
.................... // Make sure the port used has pull-up resistors (or the LCD) on 
.................... // the column pins 
....................  
....................  
.................... #if defined(__PCH__) 
.................... #if defined use_portb_kbd 
....................    #byte kbd = 0xF81                   // This puts the entire structure 
.................... #else 
....................    #byte kbd = 0xF83                   // This puts the entire structure 
.................... #endif 
.................... #else 
.................... #if defined use_portb_kbd 
....................    #byte kbd = 6                  // on to port B (at address 6) 
.................... #else 
....................    #byte kbd = 8                 // on to port D (at address 8) 
.................... #endif 
.................... #endif 
....................  
.................... #if defined use_portb_kbd 
....................    #define set_tris_kbd(x) set_tris_b(x) 
.................... #else 
....................    #define set_tris_kbd(x) set_tris_d(x) 
.................... #endif 
....................  
....................  
....................  
.................... //Keypad connection:   (for example column 0 is B2) 
.................... //                Bx: 
....................  
.................... #ifdef blue_keypad  ///////////////////////////////////// For the blue keypad 
.................... #define COL0 (1 << 2) 
.................... #define COL1 (1 << 3) 
.................... #define COL2 (1 << 6) 
....................  
.................... #define ROW0 (1 << 4) 
.................... #define ROW1 (1 << 7) 
.................... #define ROW2 (1 << 1) 
.................... #define ROW3 (1 << 5) 
....................  
.................... #else ////////////////////////////////////////////////// For the black keypad 
.................... #define COL0 (1 << 5) 
.................... #define COL1 (1 << 6) 
.................... #define COL2 (1 << 7) 
....................  
.................... #define ROW0 (1 << 1) 
.................... #define ROW1 (1 << 2) 
.................... #define ROW2 (1 << 3) 
.................... #define ROW3 (1 << 4) 
....................  
.................... #endif 
....................  
.................... #define ALL_ROWS (ROW0|ROW1|ROW2|ROW3) 
.................... #define ALL_PINS (ALL_ROWS|COL0|COL1|COL2) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][3] = {{'1','2','3'}, 
....................                          {'4','5','6'}, 
....................                          {'7','8','9'}, 
....................                          {'*','0','#'}}; 
....................  
.................... #define KBD_DEBOUNCE_FACTOR 33    // Set this number to apx n/333 where 
....................                                   // n is the number of times you expect 
....................                                   // to call kbd_getc each second 
....................  
....................  
.................... void kbd_init() { 
.................... } 
*
0076:  BCF    0A.3
0077:  BCF    0A.4
0078:  GOTO   22F (RETURN)
....................  
.................... char kbd_getc( ) { 
....................    static BYTE kbd_call_count; 
*
021B:  BCF    03.6
021C:  CLRF   20
....................    static short int kbd_down; 
021D:  BCF    21.0
....................    static char last_key; 
021E:  CLRF   22
....................    static BYTE col; 
021F:  CLRF   23
....................  
....................    BYTE kchar; 
....................    BYTE row; 
....................  
....................    kchar='\0'; 
*
0137:  CLRF   2D
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
0138:  INCF   20,F
0139:  MOVF   20,W
013A:  SUBLW  21
013B:  BTFSC  03.0
013C:  GOTO   1B9
....................        switch (col) { 
013D:  MOVF   23,W
013E:  BTFSC  03.2
013F:  GOTO   147
0140:  XORLW  01
0141:  BTFSC  03.2
0142:  GOTO   14D
0143:  XORLW  03
0144:  BTFSC  03.2
0145:  GOTO   153
0146:  GOTO   159
....................          case 0   : set_tris_kbd(ALL_PINS&~COL0); 
0147:  MOVLW  DE
0148:  BSF    03.5
0149:  MOVWF  06
....................                     kbd=~COL0&ALL_PINS; 
014A:  BCF    03.5
014B:  MOVWF  06
....................                     break; 
014C:  GOTO   159
....................          case 1   : set_tris_kbd(ALL_PINS&~COL1); 
014D:  MOVLW  BE
014E:  BSF    03.5
014F:  MOVWF  06
....................                     kbd=~COL1&ALL_PINS; 
0150:  BCF    03.5
0151:  MOVWF  06
....................                     break; 
0152:  GOTO   159
....................          case 2   : set_tris_kbd(ALL_PINS&~COL2); 
0153:  MOVLW  7E
0154:  BSF    03.5
0155:  MOVWF  06
....................                     kbd=~COL2&ALL_PINS; 
0156:  BCF    03.5
0157:  MOVWF  06
....................                     break; 
0158:  GOTO   159
....................        } 
....................  
....................        if(kbd_down) { 
0159:  BTFSS  21.0
015A:  GOTO   165
....................          if((kbd & (ALL_ROWS))==(ALL_ROWS)) { 
015B:  MOVF   06,W
015C:  ANDLW  1E
015D:  SUBLW  1E
015E:  BTFSS  03.2
015F:  GOTO   164
....................            kbd_down=FALSE; 
0160:  BCF    21.0
....................            kchar=last_key; 
0161:  MOVF   22,W
0162:  MOVWF  2D
....................            last_key='\0'; 
0163:  CLRF   22
....................          } 
....................        } else { 
0164:  GOTO   1B8
....................           if((kbd & (ALL_ROWS))!=(ALL_ROWS)) { 
0165:  MOVF   06,W
0166:  ANDLW  1E
0167:  SUBLW  1E
0168:  BTFSC  03.2
0169:  GOTO   1B3
....................              if((kbd & ROW0)==0) 
016A:  MOVF   06,W
016B:  ANDLW  02
016C:  BTFSS  03.2
016D:  GOTO   170
....................                row=0; 
016E:  CLRF   2E
....................              else if((kbd & ROW1)==0) 
016F:  GOTO   184
0170:  MOVF   06,W
0171:  ANDLW  04
0172:  BTFSS  03.2
0173:  GOTO   177
....................                row=1; 
0174:  MOVLW  01
0175:  MOVWF  2E
....................              else if((kbd & ROW2)==0) 
0176:  GOTO   184
0177:  MOVF   06,W
0178:  ANDLW  08
0179:  BTFSS  03.2
017A:  GOTO   17E
....................                row=2; 
017B:  MOVLW  02
017C:  MOVWF  2E
....................              else if((kbd & ROW3)==0) 
017D:  GOTO   184
017E:  MOVF   06,W
017F:  ANDLW  10
0180:  BTFSS  03.2
0181:  GOTO   184
....................                row=3; 
0182:  MOVLW  03
0183:  MOVWF  2E
....................              last_key =KEYS[row][col]; 
0184:  MOVF   2E,W
0185:  MOVWF  2F
0186:  MOVLW  03
0187:  MOVWF  30
*
01AC:  MOVF   23,W
01AD:  ADDWF  78,W
01AE:  CALL   004
01AF:  MOVWF  78
01B0:  MOVWF  22
....................              kbd_down = TRUE; 
01B1:  BSF    21.0
....................           } else { 
01B2:  GOTO   1B8
....................              ++col; 
01B3:  INCF   23,F
....................              if(col==3) 
01B4:  MOVF   23,W
01B5:  SUBLW  03
01B6:  BTFSC  03.2
....................                col=0; 
01B7:  CLRF   23
....................           } 
....................        } 
....................       kbd_call_count=0; 
01B8:  CLRF   20
....................    } 
....................   set_tris_kbd(ALL_PINS); 
01B9:  MOVLW  FE
01BA:  BSF    03.5
01BB:  MOVWF  06
....................   return(kchar); 
01BC:  BCF    03.5
01BD:  MOVF   2D,W
01BE:  MOVWF  78
.................... } 
01BF:  RETLW  00
....................  
....................                                  // manejar el teclado telefónico:*/ 
.................... #INCLUDE<LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCDD.C                                //// 
.................... ////                 Driver for common LCD modules                     //// 
.................... ////                                                                   //// 
.................... ////  lcd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.     //// 
.................... ////                     The following have special meaning:           //// 
.................... ////                      \f  Clear display                            //// 
.................... ////                      \n  Go to start of second line               //// 
.................... ////                      \b  Move back one position                   //// 
.................... ////                                                                   //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)    //// 
.................... ////                                                                   //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // As defined in the following structure the pin connection is as follows: 
.................... //     D0  enable 
.................... //     D1  rs 
.................... //     D2  rw 
.................... //     D4  D4 
.................... //     D5  D5 
.................... //     D6  D6 
.................... //     D7  D7 
.................... // 
.................... //   LCD pins D0-D3 are not used and PIC D3 is not used. 
....................  
.................... // Un-comment the following define to use port B 
.................... // #define use_portb_lcd TRUE 
....................  
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            BOOLEAN enable;           // on to an I/O port to gain 
....................            BOOLEAN rs;               // access to the LCD pins. 
....................            BOOLEAN rw;               // The bits are allocated from 
....................            BOOLEAN unused;           // low order up.  ENABLE will 
....................            int     data : 4;         // be pin B0. 
....................         } lcd; 
....................  
....................  
.................... #if defined use_portb_lcd 
....................    //#locate lcd = getenv("sfr:PORTB")    // This puts the entire structure over the port 
....................    #ifdef __pch__ 
....................     #locate lcd = 0xf81 
....................    #else 
....................     #locate lcd = 6 
....................    #endif 
....................    #define set_tris_lcd(x) set_tris_b(x) 
.................... #else 
....................    //#locate lcd = getenv("sfr:PORTD")    // This puts the entire structure over the port 
....................    #ifdef __pch__ 
....................     #locate lcd = 0xf83 
....................    #else 
....................     #locate lcd = 8 
....................    #endif 
....................    #define set_tris_lcd(x) set_tris_d(x) 
.................... #endif 
....................  
.................... #ifndef lcd_type 
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {0,0,0,0,0}; // For write mode all pins are out 
.................... struct lcd_pin_map const LCD_READ = {0,0,0,0,15}; // For read mode data pins are in 
....................  
....................  
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................       set_tris_lcd(LCD_READ); 
*
009B:  MOVLW  F0
009C:  BSF    03.5
009D:  MOVWF  06
....................       lcd.rw = 1; 
009E:  BCF    03.5
009F:  BSF    06.2
....................       delay_cycles(1); 
00A0:  NOP
....................       lcd.enable = 1; 
00A1:  BSF    06.0
....................       delay_cycles(1); 
00A2:  NOP
....................       high = lcd.data; 
00A3:  MOVF   06,W
00A4:  SWAPF  06,W
00A5:  ANDLW  0F
00A6:  MOVWF  36
....................       lcd.enable = 0; 
00A7:  BCF    06.0
....................       delay_cycles(1); 
00A8:  NOP
....................       lcd.enable = 1; 
00A9:  BSF    06.0
....................       delay_us(1); 
00AA:  NOP
....................       low = lcd.data; 
00AB:  MOVF   06,W
00AC:  SWAPF  06,W
00AD:  ANDLW  0F
00AE:  MOVWF  35
....................       lcd.enable = 0; 
00AF:  BCF    06.0
....................       set_tris_lcd(LCD_WRITE); 
00B0:  MOVLW  00
00B1:  BSF    03.5
00B2:  MOVWF  06
....................       return( (high<<4) | low); 
00B3:  BCF    03.5
00B4:  SWAPF  36,W
00B5:  MOVWF  77
00B6:  MOVLW  F0
00B7:  ANDWF  77,F
00B8:  MOVF   77,W
00B9:  IORWF  35,W
00BA:  MOVWF  78
.................... } 
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd.data = n; 
*
008E:  SWAPF  36,W
008F:  ANDLW  F0
0090:  MOVWF  77
0091:  MOVLW  0F
0092:  ANDWF  06,W
0093:  IORWF  77,W
0094:  MOVWF  06
....................       delay_cycles(1); 
0095:  NOP
....................       lcd.enable = 1; 
0096:  BSF    06.0
....................       delay_us(2); 
0097:  GOTO   098
....................       lcd.enable = 0; 
0098:  BCF    06.0
.................... } 
0099:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd.rs = 0; 
009A:  BCF    06.1
....................       while ( bit_test(lcd_read_byte(),7) ) ; 
*
00BB:  MOVF   78,W
00BC:  MOVWF  35
00BD:  BTFSC  35.7
00BE:  GOTO   09B
....................       lcd.rs = address; 
00BF:  BTFSS  33.0
00C0:  BCF    06.1
00C1:  BTFSC  33.0
00C2:  BSF    06.1
....................       delay_cycles(1); 
00C3:  NOP
....................       lcd.rw = 0; 
00C4:  BCF    06.2
....................       delay_cycles(1); 
00C5:  NOP
....................       lcd.enable = 0; 
00C6:  BCF    06.0
....................       lcd_send_nibble(n >> 4); 
00C7:  SWAPF  34,W
00C8:  MOVWF  35
00C9:  MOVLW  0F
00CA:  ANDWF  35,F
00CB:  MOVF   35,W
00CC:  MOVWF  36
00CD:  CALL   08E
....................       lcd_send_nibble(n & 0xf); 
00CE:  MOVF   34,W
00CF:  ANDLW  0F
00D0:  MOVWF  35
00D1:  MOVWF  36
00D2:  CALL   08E
.................... } 
00D3:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................     set_tris_lcd(LCD_WRITE); 
00D4:  MOVLW  00
00D5:  BSF    03.5
00D6:  MOVWF  06
....................     lcd.rs = 0; 
00D7:  BCF    03.5
00D8:  BCF    06.1
....................     lcd.rw = 0; 
00D9:  BCF    06.2
....................     lcd.enable = 0; 
00DA:  BCF    06.0
....................     delay_ms(15); 
00DB:  MOVLW  0F
00DC:  MOVWF  2F
00DD:  CALL   079
....................     for(i=1;i<=3;++i) { 
00DE:  MOVLW  01
00DF:  MOVWF  2D
00E0:  MOVF   2D,W
00E1:  SUBLW  03
00E2:  BTFSS  03.0
00E3:  GOTO   0EC
....................        lcd_send_nibble(3); 
00E4:  MOVLW  03
00E5:  MOVWF  36
00E6:  CALL   08E
....................        delay_ms(5); 
00E7:  MOVLW  05
00E8:  MOVWF  2F
00E9:  CALL   079
....................     } 
00EA:  INCF   2D,F
00EB:  GOTO   0E0
....................     lcd_send_nibble(2); 
00EC:  MOVLW  02
00ED:  MOVWF  36
00EE:  CALL   08E
....................     for(i=0;i<=3;++i) 
00EF:  CLRF   2D
00F0:  MOVF   2D,W
00F1:  SUBLW  03
00F2:  BTFSS  03.0
00F3:  GOTO   0FD
....................        lcd_send_byte(0,LCD_INIT_STRING[i]); 
00F4:  MOVF   2D,W
00F5:  CALL   014
00F6:  MOVWF  2E
00F7:  CLRF   33
00F8:  MOVF   2E,W
00F9:  MOVWF  34
00FA:  CALL   09A
00FB:  INCF   2D,F
00FC:  GOTO   0F0
.................... } 
00FD:  BCF    0A.3
00FE:  BCF    0A.4
00FF:  GOTO   230 (RETURN)
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
0100:  DECFSZ 30,W
0101:  GOTO   103
0102:  GOTO   106
....................      address=lcd_line_two; 
0103:  MOVLW  40
0104:  MOVWF  31
....................    else 
0105:  GOTO   107
....................      address=0; 
0106:  CLRF   31
....................    address+=x-1; 
0107:  MOVLW  01
0108:  SUBWF  2F,W
0109:  ADDWF  31,F
....................    lcd_send_byte(0,0x80|address); 
010A:  MOVF   31,W
010B:  IORLW  80
010C:  MOVWF  32
010D:  CLRF   33
010E:  MOVF   32,W
010F:  MOVWF  34
0110:  CALL   09A
.................... } 
0111:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
0112:  MOVF   2E,W
0113:  XORLW  0C
0114:  BTFSC  03.2
0115:  GOTO   11D
0116:  XORLW  06
0117:  BTFSC  03.2
0118:  GOTO   125
0119:  XORLW  02
011A:  BTFSC  03.2
011B:  GOTO   12B
011C:  GOTO   130
....................      case '\f'   : lcd_send_byte(0,1); 
011D:  CLRF   33
011E:  MOVLW  01
011F:  MOVWF  34
0120:  CALL   09A
....................                    delay_ms(2); 
0121:  MOVLW  02
0122:  MOVWF  2F
0123:  CALL   079
....................                                            break; 
0124:  GOTO   136
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
0125:  MOVLW  01
0126:  MOVWF  2F
0127:  MOVLW  02
0128:  MOVWF  30
0129:  CALL   100
012A:  GOTO   136
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
012B:  CLRF   33
012C:  MOVLW  10
012D:  MOVWF  34
012E:  CALL   09A
012F:  GOTO   136
....................      default     : lcd_send_byte(1,c);     break; 
0130:  MOVLW  01
0131:  MOVWF  33
0132:  MOVF   2E,W
0133:  MOVWF  34
0134:  CALL   09A
0135:  GOTO   136
....................    } 
.................... } 
0136:  RETLW  00
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................     lcd.rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd.rs=0; 
....................     return(value); 
.................... } 
....................  
.................... #BYTE    PORTC= 7 
.................... #BYTE    PORTB= 6 
.................... #BYTE    WPUB=0x95 
.................... #DEFINE  LED1  PORTC,7 
.................... #DEFINE  LED2  PORTC,4 
....................  
.................... INT CONT; 
.................... BYTE J=16; 
*
0220:  MOVLW  10
0221:  MOVWF  25
.................... CHAR K; 
.................... INT MIL,CEN,DEC,UNI,VAL; 
....................  
.................... VOID TECLADO() 
.................... { 
....................    k=kbd_getc();                 // Llamar la función del teclado y almacenar  
*
01C0:  CALL   137
01C1:  MOVF   78,W
01C2:  MOVWF  26
....................                                  // el valor digitado en una variable tipo  
....................                                  // caracter. Si no se oprime ninguna tecla el  
....................                                  // teclado retornara el carácter nulo.*/ 
....................    WHILE(k=='\0')                // si no se oprime ninguna tecla sigue  
....................                                  // llamando al teclado. 
....................    { 
01C3:  MOVF   26,F
01C4:  BTFSS  03.2
01C5:  GOTO   1CA
....................       k=kbd_getc(); 
01C6:  CALL   137
01C7:  MOVF   78,W
01C8:  MOVWF  26
....................    } 
01C9:  GOTO   1C3
....................    IF( (k!='\0'))          
01CA:  MOVF   26,F
01CB:  BTFSC  03.2
01CC:  GOTO   207
....................    { 
....................    IF(K=='0')                    // Si K es igual a cero  
01CD:  MOVF   26,W
01CE:  SUBLW  30
01CF:  BTFSC  03.2
....................       VAL=0;                     // Val es igual a cero 
01D0:  CLRF   2B
....................    IF(K=='1') 
01D1:  MOVF   26,W
01D2:  SUBLW  31
01D3:  BTFSS  03.2
01D4:  GOTO   1D7
....................       VAL=1; 
01D5:  MOVLW  01
01D6:  MOVWF  2B
....................    IF(K=='2') 
01D7:  MOVF   26,W
01D8:  SUBLW  32
01D9:  BTFSS  03.2
01DA:  GOTO   1DD
....................       VAL=2; 
01DB:  MOVLW  02
01DC:  MOVWF  2B
....................    IF(K=='3') 
01DD:  MOVF   26,W
01DE:  SUBLW  33
01DF:  BTFSS  03.2
01E0:  GOTO   1E3
....................       VAL=3; 
01E1:  MOVLW  03
01E2:  MOVWF  2B
....................    IF(K=='4') 
01E3:  MOVF   26,W
01E4:  SUBLW  34
01E5:  BTFSS  03.2
01E6:  GOTO   1E9
....................       VAL=4; 
01E7:  MOVLW  04
01E8:  MOVWF  2B
....................    IF(K=='5') 
01E9:  MOVF   26,W
01EA:  SUBLW  35
01EB:  BTFSS  03.2
01EC:  GOTO   1EF
....................       VAL=5; 
01ED:  MOVLW  05
01EE:  MOVWF  2B
....................    IF(K=='6') 
01EF:  MOVF   26,W
01F0:  SUBLW  36
01F1:  BTFSS  03.2
01F2:  GOTO   1F5
....................       VAL=6; 
01F3:  MOVLW  06
01F4:  MOVWF  2B
....................    IF(K=='7') 
01F5:  MOVF   26,W
01F6:  SUBLW  37
01F7:  BTFSS  03.2
01F8:  GOTO   1FB
....................       VAL=7; 
01F9:  MOVLW  07
01FA:  MOVWF  2B
....................    IF(K=='8') 
01FB:  MOVF   26,W
01FC:  SUBLW  38
01FD:  BTFSS  03.2
01FE:  GOTO   201
....................       VAL=8; 
01FF:  MOVLW  08
0200:  MOVWF  2B
....................    IF(K=='9') 
0201:  MOVF   26,W
0202:  SUBLW  39
0203:  BTFSS  03.2
0204:  GOTO   207
....................       VAL=9; 
0205:  MOVLW  09
0206:  MOVWF  2B
....................   } 
.................... } 
0207:  RETLW  00
....................  
.................... VOID MAIN() 
.................... { 
0208:  CLRF   04
0209:  BCF    03.7
020A:  MOVLW  1F
020B:  ANDWF  03,F
020C:  BSF    03.5
020D:  BSF    03.6
020E:  MOVF   09,W
020F:  ANDLW  C0
0210:  MOVWF  09
0211:  BCF    03.6
0212:  BCF    1F.4
0213:  BCF    1F.5
0214:  MOVLW  00
0215:  BSF    03.6
0216:  MOVWF  08
0217:  BCF    03.5
0218:  CLRF   07
0219:  CLRF   08
021A:  CLRF   09
....................    PORT_B_PULLUPS(TRUE);         // En el programa principal habilitar las  
*
0224:  MOVLW  01
0225:  BSF    03.5
0226:  MOVWF  15
0227:  BCF    01.7
....................                                  // resistencias pullup del puerto B, con esto     
....................                                  // simplemente se habilitan internamente unas  
....................                                  // resistencias del puerto B a +V.*/ 
....................    WPUB=255;    
0228:  MOVLW  FF
0229:  MOVWF  15
....................    SET_TRIS_C(0B00000000); 
*
0222:  MOVLW  FF
0223:  MOVWF  2C
*
022A:  MOVLW  00
022B:  MOVWF  07
022C:  BCF    03.5
022D:  MOVWF  2C
....................    KBD_INIT();                   // Inicializar el driver del teclado en el  
022E:  GOTO   076
....................                                  // programa principal 
....................    LCD_INIT(); 
022F:  GOTO   0D4
....................    PORTC=0; 
0230:  CLRF   07
....................     
....................    WHILE(TRUE) 
....................    { 
....................       LCD_GOTOXY(1,1); 
0231:  MOVLW  01
0232:  MOVWF  2F
0233:  MOVWF  30
0234:  CALL   100
....................       LCD_PUTC("   BIENVENIDOS  "); 
0235:  CLRF   2D
0236:  MOVF   2D,W
0237:  CALL   01C
0238:  IORLW  00
0239:  BTFSC  03.2
023A:  GOTO   23F
023B:  INCF   2D,F
023C:  MOVWF  2E
023D:  CALL   112
023E:  GOTO   236
....................       LCD_GOTOXY(1,2); 
023F:  MOVLW  01
0240:  MOVWF  2F
0241:  MOVLW  02
0242:  MOVWF  30
0243:  CALL   100
....................       LCD_PUTC(" DIGITE  CLAVE  "); 
0244:  CLRF   2D
0245:  MOVF   2D,W
0246:  CALL   031
0247:  IORLW  00
0248:  BTFSC  03.2
0249:  GOTO   24E
024A:  INCF   2D,F
024B:  MOVWF  2E
024C:  CALL   112
024D:  GOTO   245
....................       DELAY_MS(1000); 
024E:  MOVLW  04
024F:  MOVWF  2D
0250:  MOVLW  FA
0251:  MOVWF  2F
0252:  CALL   079
0253:  DECFSZ 2D,F
0254:  GOTO   250
....................  
....................       TECLADO(); 
0255:  CALL   1C0
....................       LCD_PUTC("\f"); 
0256:  CLRF   2D
0257:  MOVF   2D,W
0258:  CALL   046
0259:  IORLW  00
025A:  BTFSC  03.2
025B:  GOTO   260
025C:  INCF   2D,F
025D:  MOVWF  2E
025E:  CALL   112
025F:  GOTO   257
....................       LCD_GOTOXY(1,1); 
0260:  MOVLW  01
0261:  MOVWF  2F
0262:  MOVWF  30
0263:  CALL   100
....................  
....................       IF((k!='#')&&(k!='*')) 
0264:  MOVF   26,W
0265:  SUBLW  23
0266:  BTFSC  03.2
0267:  GOTO   271
0268:  MOVF   26,W
0269:  SUBLW  2A
026A:  BTFSC  03.2
026B:  GOTO   271
....................       { 
....................          lcd_putc('*'); 
026C:  MOVLW  2A
026D:  MOVWF  2E
026E:  CALL   112
....................          UNI=VAL; 
026F:  MOVF   2B,W
0270:  MOVWF  2A
....................       } 
....................       TECLADO(); 
0271:  CALL   1C0
....................  
....................       IF((k!='#')&&(k!='*')) 
0272:  MOVF   26,W
0273:  SUBLW  23
0274:  BTFSC  03.2
0275:  GOTO   27F
0276:  MOVF   26,W
0277:  SUBLW  2A
0278:  BTFSC  03.2
0279:  GOTO   27F
....................       { 
....................          lcd_putc('*'); 
027A:  MOVLW  2A
027B:  MOVWF  2E
027C:  CALL   112
....................          DEC=VAL; 
027D:  MOVF   2B,W
027E:  MOVWF  29
....................       } 
....................       TECLADO(); 
027F:  CALL   1C0
....................        
....................       IF((k!='#')&&(k!='*')) 
0280:  MOVF   26,W
0281:  SUBLW  23
0282:  BTFSC  03.2
0283:  GOTO   28D
0284:  MOVF   26,W
0285:  SUBLW  2A
0286:  BTFSC  03.2
0287:  GOTO   28D
....................       { 
....................          lcd_putc('*'); 
0288:  MOVLW  2A
0289:  MOVWF  2E
028A:  CALL   112
....................          CEN=VAL; 
028B:  MOVF   2B,W
028C:  MOVWF  28
....................       } 
....................       TECLADO(); 
028D:  CALL   1C0
....................        
....................       IF((k!='#')&&(k!='*')) 
028E:  MOVF   26,W
028F:  SUBLW  23
0290:  BTFSC  03.2
0291:  GOTO   29B
0292:  MOVF   26,W
0293:  SUBLW  2A
0294:  BTFSC  03.2
0295:  GOTO   29B
....................       { 
....................          lcd_putc('*'); 
0296:  MOVLW  2A
0297:  MOVWF  2E
0298:  CALL   112
....................          MIL=VAL; 
0299:  MOVF   2B,W
029A:  MOVWF  27
....................       } 
....................        
....................       TECLADO(); 
029B:  CALL   1C0
....................        
....................       WHILE((k!='#')) 
....................       { 
029C:  MOVF   26,W
029D:  SUBLW  23
029E:  BTFSC  03.2
029F:  GOTO   2A2
....................          TECLADO(); 
02A0:  CALL   1C0
....................       } 
02A1:  GOTO   29C
....................      
....................       IF((UNI==1)&&(DEC==2)&&(CEN==3)&&(MIL==4))  // Aquí se compara si 
02A2:  DECFSZ 2A,W
02A3:  GOTO   2D2
02A4:  MOVF   29,W
02A5:  SUBLW  02
02A6:  BTFSS  03.2
02A7:  GOTO   2D2
02A8:  MOVF   28,W
02A9:  SUBLW  03
02AA:  BTFSS  03.2
02AB:  GOTO   2D2
02AC:  MOVF   27,W
02AD:  SUBLW  04
02AE:  BTFSS  03.2
02AF:  GOTO   2D2
....................                                                   // los números digitados  
....................                                                   // están correctos.*/ 
....................       { 
....................          LCD_PUTC("\f");                          // Se borra LCD 
02B0:  CLRF   2D
02B1:  MOVF   2D,W
02B2:  CALL   046
02B3:  IORLW  00
02B4:  BTFSC  03.2
02B5:  GOTO   2BA
02B6:  INCF   2D,F
02B7:  MOVWF  2E
02B8:  CALL   112
02B9:  GOTO   2B1
....................          LCD_GOTOXY(1,1);                         // Se ubica en la posición 1,1 
02BA:  MOVLW  01
02BB:  MOVWF  2F
02BC:  MOVWF  30
02BD:  CALL   100
....................          LCD_PUTC(" CLAVE CORRECTA "); 
02BE:  CLRF   2D
02BF:  MOVF   2D,W
02C0:  CALL   04C
02C1:  IORLW  00
02C2:  BTFSC  03.2
02C3:  GOTO   2C8
02C4:  INCF   2D,F
02C5:  MOVWF  2E
02C6:  CALL   112
02C7:  GOTO   2BF
....................          BIT_SET(LED1); 
02C8:  BSF    07.7
....................          DELAY_MS(2000); 
02C9:  MOVLW  08
02CA:  MOVWF  2D
02CB:  MOVLW  FA
02CC:  MOVWF  2F
02CD:  CALL   079
02CE:  DECFSZ 2D,F
02CF:  GOTO   2CB
....................          BIT_CLEAR(LED1); 
02D0:  BCF    07.7
....................       } 
....................      
....................       ELSE 
02D1:  GOTO   2F4
....................       { 
....................          LCD_PUTC("\f"); 
02D2:  CLRF   2D
02D3:  MOVF   2D,W
02D4:  CALL   046
02D5:  IORLW  00
02D6:  BTFSC  03.2
02D7:  GOTO   2DC
02D8:  INCF   2D,F
02D9:  MOVWF  2E
02DA:  CALL   112
02DB:  GOTO   2D3
....................          LCD_GOTOXY(1,2); 
02DC:  MOVLW  01
02DD:  MOVWF  2F
02DE:  MOVLW  02
02DF:  MOVWF  30
02E0:  CALL   100
....................          LCD_PUTC(" CLAVE INVALIDA "); 
02E1:  CLRF   2D
02E2:  MOVF   2D,W
02E3:  CALL   061
02E4:  IORLW  00
02E5:  BTFSC  03.2
02E6:  GOTO   2EB
02E7:  INCF   2D,F
02E8:  MOVWF  2E
02E9:  CALL   112
02EA:  GOTO   2E2
....................          BIT_SET(LED2); 
02EB:  BSF    07.4
....................          DELAY_MS(4000); 
02EC:  MOVLW  10
02ED:  MOVWF  2D
02EE:  MOVLW  FA
02EF:  MOVWF  2F
02F0:  CALL   079
02F1:  DECFSZ 2D,F
02F2:  GOTO   2EE
....................          BIT_CLEAR(LED2); 
02F3:  BCF    07.4
....................       } 
....................    } 
02F4:  GOTO   231
.................... } 
....................  
02F5:  SLEEP

Configuration Fuses:
   Word  1: 2CF1   XT NOWDT NOPUT MCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   NOWRT BORV40
